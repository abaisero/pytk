from functools import partial, wraps
from timeit import default_timer as timer


################################################################################
# Memoization
################################################################################

# NOTE use lru_cache!!!

def memoize(f):
    """Decorator: cache the results of f for the same parameters.
    The decorated function is only called if the parameters differ from
    previous calls.
    Cache is really useful for recursive functions!

    Warning:
        Only use this with pure functions/functons without side effects.
    """
    cache = dict()

    @wraps(f)
    def wrapper(*args, **kwargs):
        key = tuple(args) + tuple(sorted(kwargs.items()))
        if key not in cache:
            cache[key] = f(*args, **kwargs)
        return cache[key]
    return wrapper


class memoizemethod(object):
    """cache the return value of a method

    This class is meant to be used as a decorator of methods. The return value
    from a given method invocation will be cached on the instance whose method
    was invoked. All arguments passed to a method decorated with memoize must
    be hashable.

    If a memoized method is invoked directly on its class the result will not
    be cached. Instead the method will be invoked like a static method:
    class Obj(object):
        @memoize
        def add_to(self, arg):
            return self + arg
    Obj.add_to(1) # not enough arguments
    Obj.add_to(1, 2) # returns 3, result is not cached
    """
    def __init__(self, func):
        self.func = func
    def __get__(self, obj, objtype=None):
        if obj is None:
            return self.func
        return partial(self, obj)
    def __call__(self, *args, **kw):
        obj = args[0]
        try:
            cache = obj.__cache
        except AttributeError:
            cache = obj.__cache = {}
        key = (self.func, args[1:], frozenset(kw.items()))
        try:
            res = cache[key]
        except KeyError:
            res = cache[key] = self.func(*args, **kw)
        return res







def boolnot(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        return not f(*args, **kwargs)
    return wrapper


class setter(property):
    """ Memoize a property such that it is computed only once """

    def __init__(self, fset, doc=None):
        super(setter, self).__init__(fget=None, fset=fset, doc=doc)


def monkeypatch(cls):
    def decorator(func):
        if cls is not None:
            try:
                fname = func.func_name
            except AttributeError:
                fname = func.__func__.func_name
            setattr(cls, fname, func)
        return func
    return decorator


